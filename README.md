CS241 Final Project

Nicolas Jandeleit, Oliver Ripps, Ryan Kim, and Will Kennedy

Introduction
	For our final project, we have created a PvP soccer video game, using Pygame, with a shuffleboard type twist. There are two teams, Arsenal and Chelsea, each comprised of 4 players which are circular pucks. The game is taken in turns, and positions are reset when one team scores. Once one team reaches 3 goals, the game ends and you have the option to replay from a game over screen. 
How The Game Works
	When it is your team’s turn, click the player you would like to move(this will highlight it). Use the A(counter-clockwise) and D(clockwise) keys to move the angle which is shown with a line and the W(more power) and S(less power) keys to change the power(displayed in the power bar on the top right). When you are done adjusting, press the space bar to launch your player. Once every player and the ball stop moving, the turn has switched, now the other team can select their player and repeat the process. The ball and players will never go out of bounds, but instead, bounce off of the walls of the field. The scoreboard above the field shows the score of the game. 


Code Structure
	The game is comprised of 4 states/screens: Menu, Instructions, Game, and Game Over. Players navigate between these screens using keys with relevant instructions always displayed, altering a state variable in the code. Our code is abstracted into classes Ball, Player, and Bar. Each player is instantiated with characteristics such as position and team(which correspond to their image and coordinates) and held in a list of players. The ball is also instantiated but held in a separate variable. Both of these are unique to each “instance” of the game, whereas the power bar along with the scoreboard, title, field, and instructions all stay the same instance between games. 

Our Experience
One thing that we did really well was the strategy we used to code. Using branches, pull requests, and consistent team zoom calls, we created an environment that was conducive to productive coding. We did have struggles with getting branches to merge early on which lost us a lot of code so when in doubt we just all sent our code to one person(Oliver) and he pushed it. We won’t downplay how much of a challenge it was to be apart. Learning a new language(some of us didn’t take 150 and learn python) and a new framework in Pygame was hard, especially without being in-person to help each other. We ended up spending a lot of time learning and getting stuck on little things which I think would have been less of a problem had we been in Oberlin. It’s frustrating to think, now that we are out of time to make our project perfect, how long we spent stagnant because of external challenges. But despite this, I think we all had fun with this project, and getting to be a part of game development of something we would probably play was really cool. Additionally, we all learned a lot, particularly how to think outside of the box when coding. The first part of the project was mostly creating the infrastructure for the game and few problems really occurred, but once movement and rules/game logic came in it became very difficult. The simple movement was the first major problem we encountered. We had a power value and an angle, but in order to apply it to the player, we had to increment movement per frame. The game seemed to be going at a different rate and the player would jump around. In order to make it smooth, we had to reorganize our movement functions and vector calculations as well as change when the screen updated. Once we had that, we had to figure out how to make stuff slow down and so we introduced friction and a speed variable limit which works kind of like static friction.
	The final major obstacle, which ultimately led to the majority of the bugs in the game, was collisions. Fundamentally, the problem is that our code has to check every piece on the board every iteration of the code for touches and then transfer velocity. In real physics, balls interact right when they touch and their direction is dictated by a line drawn from the center to the tangent point of the other ball. In our code, let’s say two balls are moving 20 pixels per increment(balls have a diameter of 50), and they collide. The point of impact may be off by as much as 40 pixels because it can only check every increment, resulting in an angle that is calculated incorrectly by 40 out of 50 pixels(very bad). We can’t decrease the number of pixels pieces move each increment because then they won’t go fast enough. With more updates/frames per second, we could lower the pixel amount and maintain the same speed. This small problem which as of now we see no solution for in a program like Pygame results in our collisions not looking realistic some of the time(most of the time). These glitches in the game majorly impact the function, but code-wise, we believe are out of our control. If we had more time, we probably would have tried to write code that predicted if balls would collide well before they did and then decide the angle beforehand, not detect collision each moment, but even that may not work because of Pygame’s limitations. Also, changing the way the window updates could help. But that would take a lot of investigation. It’s frustrating to work so hard and not see a game that functions the way you want it to, but we are proud of the effort we put in and the game’s overall functioning, despite what we consider to be the game’s added “challenges”.

Sources We Used:
http://www.petercollingridge.co.uk/tutorials/pygame-physics-simulation/
https://www.pygame.org/docs/
https://www.pygame.org/wiki

